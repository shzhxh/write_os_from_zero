# 从零开始写一个操作系统
硬件和软件的接口是指令集，操作系统和用户软件的接口是系统调用。操作系统处在中间的位置，向下要使用硬件提供的接口，向上要为用户软件提供系统调用接口。理解了操作系统，计算机里的这点东西就基本上都知道了，相当于打通了任督二脉。接下来再深入硬件去实现一个CPU，然后理解指令集到高级语言的转化关系实现一个编译器，这样在系统的层面再无疑问了，这相当于打通了大周天。然后，精研数学与算法，渐至于万法全通，这天下大可以去得了。

### 关于本书

- 本书使用latex书写。tex这种纯文本的形式可以实现更方便、更精确的控制。doc这种二进制格式出了问题都无从查起。markdown格式又太过简单。
- 本书将设计成默认提供足够的背景知识，使读者不需要再查找其它资料而可以自行完成实验。
- 只有严格控制描述对象的描述层次，才能清晰的描述一个事物，从而方便其他人的理解。
- 本书将提供配套的源码。所有源码作者自己会先实现一遍，确保是可运行的。

### 关于本操作系统

- 本操作系统将实现成Linux的极简版。这意味着Linux里有的基本系统本操作系统都将具备，但都将以最简形式实现出来，目的是便于初学者学习。函数名、变量名和目录结构都尽力与Linux保持一致。
- 本操作系统将参考清华大学的教学操作系统Ucore。实际上本操作系统就是Ucore的一个变种。
- 默认开启多核，而只把单核作为多核的一个特例。对称多处理(SMP)是现代CPU的一个基本特性，是应用工程师和系统工程师都应掌握的基本知识点。虽然Ucore的实验默认是单核的，但我认为从开始就考虑多核的问题，这点复杂性的增加相比于将来的巨大收益来说，还是值得的。
- 不使用BBL。BBL是一个boot loader，目前Linux内核是需要包进BBL里才可以启动的，Ucore也需要BBL的支持。但我认为BBL太过复杂，无形中为学习者增加了很多负担。所以，本书将自己实现一个简单的boot loader。
- 同时支持riscv32和riscv64。riscv的32位指令集和64位指令集差异很小，应该是比较容易实现同时支持的。

### 关于开发环境

- 以Linux操作系统作为开发环境。本书所使用的编译器、模拟器等都是开源软件，这些开源软件都是原生支持在Linux上的。
- 使用QEMU来模拟一个RISCV系统。QEMU是开源的、功能强大的模拟器。RISCV的指令集是开源的，这样就不必像X86或ARM那样只能浮于表面，而无法深入理解硬件内部的实现了。
- 编程语言将采用C。C语言就是汇编语言换了个马甲，简单而优雅。个人认为，在新的设计思想出现之前，其它语言就是一个臃肿的C。
- 编译器将采用LLVM。Linux和Ucore都是默认使用GCC为编译器的。但GCC仅是个编译器，而LLVM有很好的分层结构，可以方便学习编译器的知识，并实现一些比较有趣的功能。